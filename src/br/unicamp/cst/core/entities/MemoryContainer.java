/*******************************************************************************
 * Copyright (c) 2012  DCA-FEEC-UNICAMP
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v3
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/lgpl.html
 * 
 * Contributors:
 *     K. Raizer, A. L. O. Paraense, R. R. Gudwin - initial API and implementation
 ******************************************************************************/

package br.unicamp.cst.core.entities;

import br.unicamp.cst.behavior.selection.AnigrafMemoryObject;
import java.util.ArrayList;
import java.util.Optional;
import java.util.function.BinaryOperator;
import java.util.function.Predicate;
//import br.unicamp.cst.behavior.selection.Anigrafs;

/**
 * This class represents a Memory Container. The Memory Container is responsible ////////////////////////////////// editar
 * for implementing an important element in the Dynamic Subsumption mechanism
 * used in CST. All the Memory Objects in a Container are of the same type, and
 * hold the same parameters. The only differences among them are that they were
 * generated by a different codelet, and they might have different evaluations.
 * An evaluation is an inner parameter from any Memory Object, which holds a
 * value (usually a real value between 0 and 1) that measures a relative
 * importance given by the codelet, and which is used by the Evaluation codelet
 * within the Container to decide which from all input Memory Objects will be
 * sent to the output.
 * 
 * @author A. L. O. Paraense
 * @see Memory
 * @see MemoryObject
 */
public class MemoryContainer implements Memory {

	private volatile ArrayList<Memory> memories;
        private volatile ArrayList<AnigrafMemoryObject> ani_memories;
	/**
	 * Type of the memory container
	 */
	private String name;
        private static final int NO_PARENT = -1; ////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
	 * Selection action mode
	 */
        private int Selection;
        ////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Creates a MemoryContainer.
	 */
	public MemoryContainer() {

		memories = new ArrayList<>();
                ani_memories = new ArrayList<>();
	}
	/**
	 * Creates a MemoryContainer.
	 * 
	 * @param type
	 *            the type of the memories inside the container.
	 */
	public MemoryContainer(String type) {

		memories = new ArrayList<>();
                ani_memories = new ArrayList<>();

		this.name = type;
	}

	/**
	 * Sets the type of the memories inside the container.
	 * 
	 * @param name
	 *            the type of the memories inside the container.
	 */
	public synchronized void setType(String name) {
		this.name = name;
                this.Selection = 0; //////////////////////////////////////////////////////////////////////////////////////////
	}
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        public Object Condorcet(ArrayList<AnigrafMemoryObject> graph, int mode) {
        if (graph == null) return(null);
        double CodeletDistance[][] = new double[graph.size()][graph.size()];
        if ((mode == 2) || (mode == 3)) {
            for (int i = 0; i < graph.size(); i++) {
                for (int j = i + 1; j < graph.size(); j++) {
                    CodeletDistance[i][j] = (float) Math.pow(((float) Math.pow(graph.get(i).getX() - graph.get(j).getX(), 2) + (float) Math.pow(graph.get(i).getY() - graph.get(j).getY(), 2)), 1.0 / 2.0);
                    CodeletDistance[j][i] = CodeletDistance[i][j];
                }
                CodeletDistance[i][i] = 0;
            }
        }
//        if ((mode == 1) || (mode == 2)) {;;
//            // Dijkstra's algorithm //////////////////////////////////////////////////////////////////////
//            int actualCodelet;
//            //   Codelet a = new Codelet();
//            int nVertices = CodeletDistance[0].length;
//            double CodeletDistance_path[][] = new double[graph.size()][graph.size()];
//            // atualiza CodeletDistance
//            for (int i = 0; i < graph.size(); i++) {
//                for (int l = 0; l < Anigrafs.get(i).edges.size(); l++) {
////                    System.out.println(graph.get(i).edges.size());
//                    for (int j = 0; j < graph.size(); j++) {
//                        if (graph.get(j).getName() == graph.get(i).edges.get(l).name) {
//                            if (mode == 1) {
//                                CodeletDistance_path[i][j] = CodeletDistance[i][j];
//                            }
//                            if (mode == 2) {
//                                CodeletDistance_path[i][j] = 1;
//                            }
//                        }
//                    }
//                }
//            }
//            if ((mode == 2) || (mode == 3)) {
//                for (int i = 0; i < graph.size(); i++) {
//                    for (int j = 0; j < graph.size(); j++) {
//                        CodeletDistance[i][j] = CodeletDistance_path[i][j];
//                    }
//                }
//            }
//            for (int o = 0; o < nVertices; o++) {
//                actualCodelet = o;
//
//                // shortestDistances[i] will hold the shortest distance from actualCodelet to i 
//                double[] shortestDistances = new double[nVertices];
//
//                // added[i] will true if vertex i is 
//                // included / in shortest edge tree 
//                // or shortest distance from src to  
//                // i is finalized 
//                boolean[] added = new boolean[nVertices];
//
//                // Initialize all distances as  
//                // INFINITE and added[] as false 
//                for (int vertexIndex = 0; vertexIndex < nVertices;
//                        vertexIndex++) {
//                    shortestDistances[vertexIndex] = Integer.MAX_VALUE;
//                    added[vertexIndex] = false;
//                }
//
//                // Distance of source vertex from 
//                // itself is always 0 
//                shortestDistances[actualCodelet] = 0;
//
//                // Parent array to store shortest 
//                // edge tree 
//                int[] parents = new int[nVertices];
//
//                // The starting vertex does not  
//                // have a parent 
//                parents[actualCodelet] = NO_PARENT;
//
//                // Find shortest edge for all  
//                // vertices 
//                for (int i = 1; i < nVertices; i++) {
//
//                    // Pick the minimum distance vertex 
//                    // from the set of vertices not yet 
//                    // processed. nearestCodelet is  
//                    // always equal to startNode in  
//                    // first iteration. 
//                    int nearestCodelet = -1;
//                    int shortestDistance = Integer.MAX_VALUE;
//                    for (int vertexIndex = 0;
//                            vertexIndex < nVertices;
//                            vertexIndex++) {
//                        if (!added[vertexIndex]
//                                && shortestDistances[vertexIndex]
//                                < shortestDistance) {
//                            nearestCodelet = vertexIndex;
//                            shortestDistance = (int) shortestDistances[vertexIndex];
//                        }
//                    }
//
//                    // Mark the picked vertex as 
//                    // processed 
//                    added[nearestCodelet] = true;
//
//                    // Update dist value of the 
//                    // adjacent vertices of the 
//                    // picked vertex. 
//                    for (int vertexIndex = 0;
//                            vertexIndex < nVertices;
//                            vertexIndex++) {
//                        double edgeDistance = CodeletDistance[nearestCodelet][vertexIndex];
//
//                        if (edgeDistance > 0
//                                && ((shortestDistance + edgeDistance)
//                                < shortestDistances[vertexIndex])) {
//                            parents[vertexIndex] = nearestCodelet;
//                            shortestDistances[vertexIndex] = shortestDistance
//                                    + edgeDistance;
//                        }
//                    }
//                }
//                for (int p = 0; p < nVertices; p++) {
//                    CodeletDistance[o][p] = shortestDistances[p];
//                }
//            }
//            ////////////////////////////////////////////////////////////////////////////////////////////////////////
//        }
        // Condorcet de fato
        int m_contest[] = new int[((int) Math.pow(graph.size(), 2) - graph.size()) / 2];
        int votes[][] = new int[graph.size()][2]; // votes[0][] -> number of wins, votes[1][] -> number of total votes
        int z = 0;
        for (int i = 0; i < graph.size(); i++) {
            for (int j = i + 1; j < graph.size(); j++) {
                for (int k = 0; k < graph.size(); k++) {
                    if (CodeletDistance[k][i] < CodeletDistance[k][j]) {
                        m_contest[z] += graph.get(k).getEvaluation();
                        votes[i][1] += graph.get(k).getEvaluation();
                    }
                    if (CodeletDistance[k][i] > CodeletDistance[k][j]) {
                        m_contest[z] -= graph.get(k).getEvaluation();
                        votes[j][1] += graph.get(k).getEvaluation();
                    }
//                    if (CodeletDistance[k][i] == CodeletDistance[k][j]) {
//                        // nao faz nada
//                        m_contest[z] -= graph.get(k).getEvaluation();
//                        votes[j][1] += graph.get(k).getEvaluation();
//                    }
                }
                if (m_contest[z] > 0) {
                    votes[i][0] += 1;
                }
                if (m_contest[z] < 0) {
                    votes[j][0] += 1;
                }
                z += 1;
            }
        }
        z = 0;
        for (int i = 1; i < graph.size(); i++) {
            if (votes[i][0] == votes[z][0]) {
                if (votes[i][1] > votes[z][1]) {
                    z = i;
                }
            }
            if (votes[i][0] > votes[z][0]) {
                z = i;
            }
        }
        AnigrafMemoryObject r = graph.get(z);
        return r.getI();
    }
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        
        

	/**
	 * Gets the info of the memory which has the greatest evaluation.
	 * 
	 * @return the info of the memory which has the greatest evaluation.
	 */
	@Override
	public synchronized Object getI() {

        Object I = null;

        double maxEval = 0.0d;       
        switch (this.Selection) {   ///////////////////////////////////////////////////////////////////////////////////////////////////////
            case 0:
                for (Memory memory : memories) {
                    double memoryEval = memory.getEvaluation();
                    
                    if (memoryEval >= maxEval) {
                        
                        maxEval = memoryEval;
                        I = memory.getI();
                        
                        
                    }
                }
                break;
            
            case 3:
                for (AnigrafMemoryObject memory : ani_memories) {
                    String memoryEval = memory.getName();
                    System.out.println(memoryEval);
                }
                System.out.println("anigraf");
                I = Condorcet(ani_memories, 3);
                break;
                //case 2
                //case 3
                //
                //
        }
        return I;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//        /**
//	 * Gets the info of the memory which has the greatest evaluation.
//	 * 
//         * @param mode
//         *            number referring to the mode
//	 * @return the info of the memory according to the selection action type
//	 */
//	public synchronized Object getI() {
//
//		Object I = null;
//                
//		double maxEval = 0.0d;
//                
//            if (mode == 0) {
//                for (Memory memory : memories) {
//
//                    double memoryEval = memory.getEvaluation();
//
//                    if (memoryEval >= maxEval) {
//
//                        maxEval = memoryEval;
//                        I = memory.getI();
//                    }
//                }
//            }
//
//		return I;
//	}
        /////////////////////////////////////////////////////////////////////////////////////////////

	/**
	 * Gets the info of the memory which has the index passed.
	 * 
	 * @param index
	 *            the index of the memory whose info is searched.
	 * @return the info of the memory which has the index passe or null is not
	 *         found.
	 */
	public synchronized Object getI(int index) {

		if (index >= 0 && index < memories.size()) {
			return (memories.get(index).getI());
		} else {
			System.out.println("Index for the " + getName()
					+ ".getI(index) method greater than the number of MemoryObjects within the MemoryContainer");
			return (null);
		}
	}

	/**
	 * Gets the info of the memory filtered by the predicate.
	 * 
	 * @param predicate
	 *            the predicate to be used to filter the stream.
	 * @return the info of the memory or null if not found.
	 */
	public synchronized Object getI(Predicate<Memory> predicate) {

		Object object = null;

		if (memories != null && memories.size() > 0) {

			Optional<Memory> optional = memories.stream().filter(predicate).findFirst();

			if (optional.isPresent()) {// Check whether optional has element you
										// are looking for

				Memory memory = optional.get();// get it from optional
				object = memory.getI();
			}

		}

		return object;

	}

	/**
	 * Gets the info of the memory reduced by the binary operator passed.
	 * 
	 * @param accumulator
	 *            the binary operator.
	 * @return the info of the memory or null if not found.
	 */
	public synchronized Object getI(BinaryOperator<Memory> accumulator) {

		Object object = null;

		if (memories != null && memories.size() > 0) {

			Optional<Memory> optional = memories.stream().reduce(accumulator);

			if (optional.isPresent()) {// Check whether optional has element you
										// are looking for

				Memory memory = optional.get();// get it from optional
				object = memory.getI();
			}

		}

		return object;

	}

	/**
	 * MemoryContainer inserts the info as a new MemoryObject in its Memory
	 * list.
	 */
	@Override
	public synchronized int setI(Object info) {
		return setI(info, -1.0d);
	}

	/**
	 * Creates a Memory Object with the info and the evaluation passed.
	 * 
	 * @param info
	 *            the info of the new Memory Object.
	 * @param evaluation
	 *            the evaluation of the new Memory Object.
	 * @return the index of the new Memory Object.
	 */
	public synchronized int setI(Object info, Double evaluation) {

		MemoryObject mo = new MemoryObject();
		mo.setI(info);
		if (evaluation != -1.0)
			mo.setEvaluation(evaluation);
		mo.setType("");

		memories.add(mo);

		return memories.indexOf(mo);

	}
           ////////////////////////////////////////////////////////////////////////////////////////////////////////
        public synchronized int setI(Object info, Double evaluation, Double x, Double y) {

		AnigrafMemoryObject mo = new AnigrafMemoryObject();
		mo.setI(info);
		if (evaluation != -1.0)
			mo.setEvaluation(evaluation);
		mo.setType("");
                mo.setX(x);
                mo.setY(y);

		ani_memories.add(mo);
             //   memories.add(mo);
		return ani_memories.indexOf(mo);

	}
   ////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Sets the info of the Memory with the index passed.
	 * 
	 * @param info
	 *            the information to be set in the
	 * @param index
	 *            the index of the memory inside the container.
	 */
	public synchronized void setI(Object info, int index) {

		if (memories != null && memories.size() > index) {

			Memory memory = memories.get(index);

			if (memory != null) {

				if (memory instanceof MemoryObject) {
					memory.setI(info);
				} else if (memory instanceof MemoryContainer) {
					((MemoryContainer) memory).setI(info, index);
				}
			}
		}

	}

	/**
	 * Sets the info and the evaluation of the memory with the index passed
	 * inside this container.
	 * 
	 * @param info
	 *            the information to be set in the.
	 * @param index
	 *            the index of the memory inside this container.
	 * @param evaluation
	 *            the evaluation to be set.
	 */
	public synchronized void setI(Object info, Double evaluation, int index) {

		if (memories != null && memories.size() > index) {

			Memory memory = memories.get(index);

			if (memory != null) {

				if (memory instanceof MemoryObject) {
					memory.setI(info);
					memory.setEvaluation(evaluation);
				} else if (memory instanceof MemoryContainer) {
					((MemoryContainer) memory).setI(info, evaluation, index);
				}
			}
		}
	}
        
	/**
	 * Gets the greatest evaluation of the memories in the memory list.
	 * 
	 * @return the greatest evaluation of the memories in the memory list.
	 */
	@Override
	public synchronized Double getEvaluation() {

		Double maxEvaluation = 0.0d;

		for (Memory memory : memories) {

			double memoryEval = memory.getEvaluation();

			if (memoryEval >= maxEvaluation)
				maxEvaluation = memoryEval;

		}

		return maxEvaluation;
	}

	/**
	 * Gets the type of the memory which has the greatest evaluation.
	 * 
	 * @return the type of the memory which has the greatest evaluation.
	 */
	@Override
	public synchronized String getName() {

		return name;
	}
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /**
	 * Sets the type of selection action container
	 * mode = 0, Subsumption, default
         * mode = 1, Anigrafs, just arrays on the graph
         * mode = 2, Anigrafs, arrays and the position of the codelets on a Cartesian plane 
         * mode = 3, Anigrafs, just the position on a Cartesian Plane (all codelets connected together)
         * mode = 4, Vectorial
         * 
	 * @param mode
	 *            the type of selection
	 */
        public synchronized void setSelecion(int mode) {
                this.Selection = mode;
	}
        
        /**
	 * Gets the type of selection action
	 * 
	 * @return the type of selection for this container
	 */
	public synchronized int getSelection() {

		return Selection;
	}
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	@Override
	public synchronized void setEvaluation(Double eval) {

		throw new UnsupportedOperationException(
				"This method is not available for MemoryContainer. Use setEvaluation(Double eval, int index) instead");

	}

	/**
	 * Sets the evaluation of the memory with the index passed inside this
	 * container.
	 * 
	 * @param eval
	 *            the evaluation to set.
	 * @param index
	 *            the index of the memory inside this container.
	 */
	public synchronized void setEvaluation(Double eval, int index) {

		if (memories != null && memories.size() > index) {

			Memory memory = memories.get(index);

			if (memory != null) {

				if (memory instanceof MemoryObject) {

					memory.setEvaluation(eval);

				} else if (memory instanceof MemoryContainer) {

					((MemoryContainer) memory).setEvaluation(eval, index);

				}

			}
		}

	}

	/**
	 * Adds a memory to this container.
	 * 
	 * @param memory
	 *            the memory to be added in this container
	 */
	public synchronized int add(Memory memory) {

		int index = -1;

		if (memory != null) {

			memories.add(memory);

			index = memories.indexOf(memory);

		}

		return index;

	}

	/**
	 * Sets the Java String info as the info and an evaluation passed to a
	 * Memory of the type passed.
	 * 
	 * @param info
	 *            Java String info.
	 * @param evaluation
	 *            the evaluation to set.
	 * @param type
	 *            the type of the Memory
	 * @return the index of the memory
	 */
	public synchronized int setI(String info, double evaluation, String type) {

		int index = -1;

		if (memories != null) {

			boolean set = false;

			for (int i = 0; i < memories.size(); i++) {

				Memory memory = memories.get(i);

				if (memory != null && memory instanceof MemoryObject) {

					MemoryObject memoryObject = (MemoryObject) memory;

					if (memoryObject.getName().equalsIgnoreCase(type)) {

						memory.setI(info);
						memory.setEvaluation(evaluation);
						index = i;
						set = true;
						break;

					}
				}

			}

			if (!set) {

				MemoryObject mo = new MemoryObject();
				mo.setI(info);
				mo.setEvaluation(evaluation);
				mo.setType(type);

				memories.add(mo);

				index = memories.indexOf(mo);

			}
		}

		return index;
	}

	/**
	 * Sets the info as the info and an evaluation passed to a Memory of the
	 * type passed.
	 * 
	 * @param info
	 *            the info.
	 * @param evaluation
	 *            the evaluation to set.
	 * @param type
	 *            the type of the Memory
	 * @return the index of the memory
	 */
	public synchronized int setI(Object info, double evaluation, String type) {

		int index = -1;

		if (memories != null) {

			boolean set = false;

			for (int i = 0; i < memories.size(); i++) {

				Memory memory = memories.get(i);

				if (memory != null && memory instanceof MemoryObject) {

					MemoryObject memoryObject = (MemoryObject) memory;

					if (memoryObject.getName().equalsIgnoreCase(type)) {

						memory.setI(info);
						memory.setEvaluation(evaluation);
						index = i;
						set = true;
						break;

					}
				}

			}

			if (!set) {

				MemoryObject mo = new MemoryObject();
				mo.setI(info);
				mo.setEvaluation(evaluation);
				mo.setType(type);

				memories.add(mo);

				index = memories.indexOf(mo);

			}
		}

		return index;
	}

	/**
	 * Gets all the memories inside this container.
	 * 
	 * @return all the memories inside this container.
	 */
	public synchronized ArrayList<Memory> getAllMemories() {
		return memories;
	}   
}
